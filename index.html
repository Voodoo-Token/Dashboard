<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Voodoo Token Investment Calculator</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      background-color: #0c3c4c;
      color: #000;
      font-family: 'Arial', sans-serif;
      margin: 0;
      padding: 10px;
    }
    .container {
      max-width: 800px;
      margin: 0 auto;
      background: #c0c0c0;
      border: 2px solid;
      border-color: #fff #000 #000 #fff;
      box-shadow: 2px 2px 0 #000;
    }
    .window {
      margin: 10px;
      background: #c0c0c0;
      border: 2px solid;
      border-color: #fff #000 #000 #fff;
    }
    .title-bar {
      background: #000080;
      color: #fff;
      padding: 2px 5px;
      font-size: 12px;
      font-weight: bold;
    }
    .content {
      padding: 10px;
    }
    .win95-input {
      background: #fff;
      border: 2px solid;
      border-color: #000 #fff #fff #000;
      padding: 2px;
      font-size: 12px;
      width: 100%;
      box-sizing: border-box;
    }
    .win95-button {
      background: #c0c0c0;
      border: 2px solid;
      border-color: #fff #000 #000 #fff;
      padding: 2px 10px;
      cursor: pointer;
      font-size: 12px;
    }
    .win95-button:active {
      border-color: #000 #fff #fff #000;
      box-shadow: inset 1px 1px 0 #000;
    }
    .custom-button {
      background: #c0c0c0;
      color: #000;
      border: 2px solid;
      border-color: #fff #000 #000 #fff;
      padding: 5px 10px;
      text-align: center;
      display: inline-block;
      margin: 5px;
      font-size: 12px;
    }
    .custom-button:active {
      border-color: #000 #fff #fff #000;
      box-shadow: inset 1px 1px 0 #000;
    }
    .error {
      color: #ff0000;
      display: none;
      font-size: 12px;
      text-align: center;
    }
    canvas {
      background: #fff;
      border: 2px solid;
      border-color: #000 #fff #fff #000;
      width: 100%;
    }
    .logo {
      width: 64px;
      height: 64px;
      margin: 5px;
      border: 2px solid;
      border-color: #fff #000 #000 #fff;
      cursor: pointer;
    }
    .logo:hover, .logo.selected {
      border-color: #FFFF00;
    }
    .token-selector {
      display: flex;
      justify-content: center;
      margin: 10px 0;
    }
    .form-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 16px;
      margin-bottom: 24px;
    }
    @media (min-width: 768px) {
      .form-grid {
        grid-template-columns: 1fr 1fr;
      }
    }
    .links-container {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
    }
    .hidden {
      display: none;
    }
    .charts-container {
      display: flex;
      justify-content: space-between;
      gap: 10px;
      max-width: 100%;
      flex-wrap: nowrap;
    }
    .holder-window {
      flex: 3;
      max-width: 60%;
    }
    .pie-window {
      flex: 2;
      max-width: 40%;
    }
    .holder-chart {
      height: 200px;
      width: 100%;
    }
    .pie-chart {
      width: 150px;
      height: 150px;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="token-selector">
      <img src="https://lcw.nyc3.cdn.digitaloceanspaces.com/production/currencies/64/vdo.png" alt="Voodoo Token Logo" class="logo selected" data-token="VDO">
      <img src="https://lcw.nyc3.cdn.digitaloceanspaces.com/production/currencies/64/__________magic.png" alt="Magic Token Logo" class="logo" data-token="__________MAGIC">
      <img src="https://lcw.nyc3.cdn.digitaloceanspaces.com/production/currencies/64/__poison.png" alt="Poison Token Logo" class="logo" data-token="__POISON">
    </div>
    <div class="window">
      <div class="title-bar">Token Investment Calculator</div>
      <div class="content">
        <form id="investmentForm">
          <div class="form-grid">
            <div>
              <label for="investment" class="block text-sm">Investment Amount (USD)</label>
              <input type="number" id="investment" step="0.01" min="0" class="win95-input" placeholder="e.g., 1000">
            </div>
            <div>
              <label for="buyPrice" class="block text-sm">Buy Price (USD per Token)</label>
              <input type="number" id="buyPrice" step="0.000001" min="0" class="win95-input" placeholder="e.g., 0.001347">
              <button type="button" id="fetchBuyPrice" class="win95-button" style="margin-top: 8px;">Check Price</button>
            </div>
            <div>
              <label for="sellPrice" class="block text-sm">Sell Price (USD per Token)</label>
              <input type="number" id="sellPrice" step="0.000001" min="0" class="win95-input" placeholder="e.g., 0.001">
              <button type="button" id="fetchSellPrice" class="win95-button" style="margin-top: 8px;">Check Price</button>
            </div>
            <div>
              <label for="investmentFee" class="block text-sm">Investment Fee (%)</label>
              <input type="number" id="investmentFee" step="0.01" min="0" class="win95-input" placeholder="e.g., 1.5">
              <label for="exitFee" class="block text-sm" style="margin-top: 16px;">Exit Fee (%)</label>
              <input type="number" id="exitFee" step="0.01" min="0" class="win95-input" placeholder="e.g., 1.5">
            </div>
          </div>
          <button type="submit" class="win95-button" style="width: 100%;">Calculate</button>
        </form>
        <p id="error" class="error">Please fill in all fields with valid numbers.</p>
      </div>
    </div>
    <div class="window">
      <div class="title-bar">Investment Results</div>
      <div class="content hidden" id="results">
        <p><strong>Units Purchased:</strong> <span id="units"></span> Tokens</p>
        <p><strong>Total Cost:</strong> $<span id="totalCost"></span></p>
        <p><strong>Total Revenue:</strong> $<span id="totalRevenue"></span></p>
        <p><strong>Profit/Loss:</strong> $<span id="profitLoss"></span></p>
        <p><strong>ROI:</strong> <span id="roi"></span>%</p>
      </div>
    </div>
    <div class="window">
      <div class="title-bar" id="chartTitle">Historical VDO Price (Last 30 Days)</div>
      <div class="content">
        <canvas id="priceChart"></canvas>
        <div id="loading" class="text-center" style="margin-top: 8px;">Loading data...</div>
        <p id="chartError" class="error" style="margin-top: 8px;">Error loading chart data.</p>
      </div>
    </div>
    <div class="charts-container">
      <div class="window holder-window">
        <div class="title-bar">Token Holders</div>
        <div class="content">
          <canvas id="holderChart" class="holder-chart"></canvas>
        </div>
      </div>
      <div class="window pie-window">
        <div class="title-bar">Token Distribution</div>
        <div class="content">
          <canvas id="pieChart" class="pie-chart"></canvas>
        </div>
      </div>
    </div>
    <div class="window">
      <div class="title-bar">What you need to know</div>
      <div class="content">
        <textarea class="win95-input" style="width: 100%; height: 96px;" id="seoText">This dashboard lets you easily track the prices of Voodoo, Magic, and Poison tokens. You can calculate potential profits or losses, view recent price trends, see how many people own the tokens, and check how the tokens are distributed-all in one simple place.</textarea>
      </div>
    </div>
    <div class="window">
      <div class="title-bar">Links</div>
      <div class="content links-container">
        <a href="https://voodootoken.com/" class="custom-button">Back to Website</a>
        <a href="https://voodootoken.com/hovihev/uploads/2025/01/Voodoo-Token-Whitepaper-V1.pdf" class="custom-button">Read Whitepaper</a>
        <a href="https://t.me/voodootokengroup/" class="custom-button">Join Telegram</a>
        <a href="https://x.com/Voodoo_Token" class="custom-button">Follow X</a>
      </div>
    </div>
  </div>

  <script>
    // LiveCoinWatch API configuration
    const API_KEY = 'ddd9175e-6cb0-4fed-babc-8a54cd255c0e';
    const API_URL = 'https://api.livecoinwatch.com/coins/single';
    const HISTORY_URL = 'https://api.livecoinwatch.com/coins/single/history';
    const PULSECHAIN_API = 'https://api.scan.pulsechain.com/api/v2';

    // Token configurations
    const tokens = {
      VDO: {
        address: '0x1c5f8e8E84AcC71650F7a627cfA5B24B80f44f00',
        color: '#000080'
      },
      MAGIC: {
        address: '0xd63b9d8d6e38cb7fbfdceede3ce92f97f5aea7ac',
        color: '#800080'
      },
      POISON: {
        address: '0xb8c8761fed2aad5c0a75561bc604531a42c452e6',
        color: '#268137'
      }
    };

    // Map token names to API codes
    const tokenCodeMap = {
      'VDO': 'VDO',
      '__________MAGIC': '__________MAGIC',
      '__POISON': '__POISON'
    };

    // Form elements
    const form = document.getElementById('investmentForm');
    const error = document.getElementById('error');
    const results = document.getElementById('results');
    const fetchBuyPriceBtn = document.getElementById('fetchBuyPrice');
    const fetchSellPriceBtn = document.getElementById('fetchSellPrice');
    const logos = document.querySelectorAll('.logo');
    const chartTitle = document.getElementById('chartTitle');
    let selectedToken = 'VDO';
    let chartInstance = null;
    let holderChartInstance = null;
    let pieChartInstance = null;

    // Token selector
    logos.forEach(logo => {
      logo.addEventListener('click', () => {
        logos.forEach(l => l.classList.remove('selected'));
        logo.classList.add('selected');
        selectedToken = logo.dataset.token;
        document.getElementById('buyPrice').value = '';
        document.getElementById('sellPrice').value = '';
        chartTitle.textContent = `Historical ${selectedToken === 'VDO' ? 'VDO' : selectedToken === '__________MAGIC' ? 'MAGIC' : 'POISON'} Price (Last 30 Days)`;
        renderChart();
        renderHolderChart(selectedToken);
        renderPieChart();
        fetchCurrentPrice(); // Update price immediately on token switch
      });
    });

    // Fetch current price for selected token
    async function fetchCurrentPrice() {
      try {
        const response = await fetch(API_URL, {
          method: 'POST',
          headers: {
            'content-type': 'application/json',
            'x-api-key': API_KEY
          },
          body: JSON.stringify({
            currency: 'USD',
            code: selectedToken,
            meta: false
          })
        });
        if (!response.ok) throw new Error(`API error: ${response.status}`);
        const data = await response.json();
        const price = parseFloat(data.rate);
        document.getElementById('error').style.display = 'none';
        return price;
      } catch (err) {
        console.error(`Error fetching current price for ${selectedToken}:`, err);
        document.getElementById('error').textContent = `Error fetching price for ${selectedToken === 'VDO' ? 'VDO' : selectedToken === '__________MAGIC' ? 'MAGIC' : 'POISON'}: ${err.message}`;
        document.getElementById('error').style.display = 'block';
        return null;
      }
    }

    // Fetch historical price data for selected token
    async function fetchHistoricalPrice() {
      const end = Date.now();
      const start = end - 30 * 24 * 60 * 60 * 1000; // Last 30 days
      document.getElementById('loading').style.display = 'block';
      document.getElementById('chartError').style.display = 'none';

      try {
        const response = await fetch(HISTORY_URL, {
          method: 'POST',
          headers: {
            'content-type': 'application/json',
            'x-api-key': API_KEY
          },
          body: JSON.stringify({
            currency: 'USD',
            code: selectedToken,
            start,
            end
          })
        });
        if (!response.ok) throw new Error(`API error: ${response.status}`);
        const data = await response.json();
        if (!data.history || !Array.isArray(data.history)) {
          throw new Error('Historical data is not an array');
        }
        if (data.history.length === 0) {
          throw new Error('No historical data available');
        }
        return data.history.map(entry => ({
          date: new Date(entry.date).toLocaleDateString([], { month: 'short', day: 'numeric' }),
          price: parseFloat(entry.rate)
        }));
      } catch (err) {
        console.error(`Error fetching historical price for ${selectedToken}:`, err);
        document.getElementById('chartError').textContent = `Error: ${err.message}`;
        document.getElementById('chartError').style.display = 'block';
        return [];
      } finally {
        document.getElementById('loading').style.display = 'none';
      }
    }

    // Fetch holder count for a token
    async function fetchHolderCount(token) {
      try {
        const tokenName = Object.keys(tokenCodeMap).find(key => tokenCodeMap[key] === token);
        const response = await fetch(`${PULSECHAIN_API}/tokens/${tokens[tokenName].address}/counters`, {
          method: 'GET',
          headers: {
            'accept': 'application/json'
          }
        });
        if (!response.ok) throw new Error(`API error: ${response.status} ${response.statusText}`);
        const data = await response.json();
        const holders = parseInt(data.token_holders_count || '0');
        console.log(`Fetched holders for ${tokenName}:`, holders);
        return holders;
      } catch (err) {
        console.error(`Error fetching holders for ${token}: ${err.message}`);
        return null;
      }
    }

    // Aggregate holder data based on time range
    function aggregateHolderData(data) {
      const today = new Date();
      const aggregated = [];
      const dailyLimit = 30; // 30 days of daily data
      const weeklyLimit = 365; // ~1 year of weekly data
      const monthlyLimit = 3 * 365; // ~3 years of monthly data

      let currentGroup = [];
      let groupType = 'daily';

      data.forEach((entry, index) => {
        const entryDate = new Date(entry.date);
        const daysDiff = (today - entryDate) / (1000 * 60 * 60 * 24);

        if (daysDiff <= dailyLimit) {
          groupType = 'daily';
          aggregated.push(entry);
        } else if (daysDiff <= weeklyLimit) {
          groupType = 'weekly';
          currentGroup.push(entry);
          if (entryDate.getDay() === 0 || index === data.length - 1) {
            if (currentGroup.length > 0) {
              const avgHolders = currentGroup.reduce((sum, e) => sum + e.holders, 0) / currentGroup.length;
              aggregated.push({
                date: currentGroup[0].date,
                holders: avgHolders
              });
              currentGroup = [];
            }
          }
        } else if (daysDiff <= monthlyLimit) {
          groupType = 'monthly';
          currentGroup.push(entry);
          if (entryDate.getDate() === 1 || index === data.length - 1) {
            if (currentGroup.length > 0) {
              const avgHolders = currentGroup.reduce((sum, e) => sum + e.holders, 0) / currentGroup.length;
              aggregated.push({
                date: currentGroup[0].date,
                holders: avgHolders
              });
              currentGroup = [];
            }
          }
        } else {
          groupType = 'yearly';
          currentGroup.push(entry);
          if (entryDate.getMonth() === 0 && entryDate.getDate() === 1 || index === data.length - 1) {
            if (currentGroup.length > 0) {
              const avgHolders = currentGroup.reduce((sum, e) => sum + e.holders, 0) / currentGroup.length;
              aggregated.push({
                date: currentGroup[0].date,
                holders: avgHolders
              });
              currentGroup = [];
            }
          }
        }
      });

      return aggregated;
    }

    // Simulate holder data (for testing, limited to recent data)
    async function getHolderData(token) {
      const cacheKey = `holder_history_${token}`;
      let holderData = getCachedData(cacheKey)?.data || [];
      const today = new Date();
      const todayStr = today.toISOString().split('T')[0];

      // Check if today's data is already stored
      if (!holderData.find(d => d.date === todayStr)) {
        const holders = await fetchHolderCount(token);
        if (holders !== null) {
          holderData.push({
            date: todayStr,
            holders
          });
          setCachedData(cacheKey, holderData, Date.now() / 1000);
        }
      }

      return aggregateHolderData(holderData);
    }

    // Helper function to get cached data from localStorage
    function getCachedData(key) {
      try {
        const data = localStorage.getItem(key);
        return data ? JSON.parse(data) : null;
      } catch (err) {
        console.error(`Error reading ${key} from localStorage:`, err);
        return null;
      }
    }

    // Helper function to set cached data in localStorage
    function setCachedData(key, data, timestamp) {
      try {
        localStorage.setItem(key, JSON.stringify({ data, timestamp }));
      } catch (err) {
        console.error(`Error saving ${key} to localStorage:`, err);
      }
    }

    // Render historical price chart
    async function renderChart() {
      const historicalData = await fetchHistoricalPrice();
      const chartContainer = document.getElementById('priceChart').parentElement;

      if (!historicalData.length) {
        chartContainer.style.display = 'none';
        return;
      }

      chartContainer.style.display = 'block';
      const ctx = document.getElementById('priceChart').getContext('2d');

      if (chartInstance) {
        chartInstance.destroy();
      }

      chartInstance = new Chart(ctx, {
        type: 'line',
        data: {
          labels: historicalData.map(d => d.date),
          datasets: [{
            label: `${selectedToken === 'VDO' ? 'VDO' : selectedToken === '__________MAGIC' ? 'MAGIC' : 'POISON'} Price (USD)`,
            data: historicalData.map(d => d.price),
            borderColor: selectedToken === 'VDO' ? '#000080' : 
                         selectedToken === '__________MAGIC' ? '#800080' : 
                         '#268137',
            backgroundColor: selectedToken === 'VDO' ? 'rgba(0, 0, 128, 0.2)' : 
                             selectedToken === '__________MAGIC' ? 'rgba(128, 0, 128, 0.2)' : 
                             'rgba(38, 129, 55, 0.2)',
            fill: true,
            pointRadius: 0,
            tension: 0.1
          }]
        },
        options: {
          responsive: true,
          scales: {
            x: { 
              title: { display: true, text: 'Date' },
              ticks: { maxTicksLimit: 6 }
            },
            y: { 
              title: { display: true, text: 'Price (USD)' },
              ticks: {
                callback: function(value) {
                  return '$' + value.toFixed(6);
                }
              }
            }
          },
          plugins: {
            legend: { display: false },
            tooltip: {
              mode: 'index',
              intersect: false,
              callbacks: {
                label: context => `$${context.parsed.y.toFixed(6)}`
              }
            }
          }
        }
      });
    }

    // Render holder chart for the selected token
    async function renderHolderChart(token) {
      const holderData = await getHolderData(token);
      const canvas = document.getElementById('holderChart');
      const ctx = canvas.getContext('2d');
      const tokenName = token === 'VDO' ? 'VDO' : token === '__________MAGIC' ? 'MAGIC' : 'POISON';

      if (holderChartInstance) {
        holderChartInstance.destroy();
      }

      if (!holderData.length) {
        holderChartInstance = new Chart(ctx, {
          type: 'line',
          data: {
            labels: ['No Data'],
            datasets: [{
              label: `${tokenName} Holders`,
              data: [0],
              borderColor: tokens[tokenName].color,
              backgroundColor: tokens[tokenName].color + '33',
              fill: true
            }]
          },
          options: {
            responsive: true,
            scales: {
              x: { title: { display: true, text: 'Date' } },
              y: { 
                title: { display: true, text: 'Holders' },
                ticks: { precision: 0 }
              }
            },
            plugins: {
              tooltip: { enabled: false },
              legend: { display: true }
            }
          }
        });
        return;
      }

      holderChartInstance = new Chart(ctx, {
        type: 'line',
        data: {
          labels: holderData.map(d => d.date),
          datasets: [{
            label: `${tokenName} Holders`,
            data: holderData.map(d => d.holders),
            borderColor: tokens[tokenName].color,
            backgroundColor: tokens[tokenName].color + '33',
            fill: true
          }]
        },
        options: {
          responsive: true,
          scales: {
            x: { title: { display: true, text: 'Date' } },
            y: { 
              title: { display: true, text: 'Holders' },
              ticks: { precision: 0 }
            }
          },
          plugins: {
            tooltip: {
              callbacks: {
                label: function(context) {
                  return `${tokenName} Holders: ${context.parsed.y.toFixed(0)}`;
                }
              }
            },
            legend: { display: true }
          }
        }
      });
    }

    // Render placeholder pie chart
    function renderPieChart() {
      const canvas = document.getElementById('pieChart');
      const ctx = canvas.getContext('2d');

      if (pieChartInstance) {
        pieChartInstance.destroy();
      }

      const tokenName = selectedToken === 'VDO' ? 'VDO' : selectedToken === '__________MAGIC' ? 'MAGIC' : 'POISON';
      pieChartInstance = new Chart(ctx, {
        type: 'pie',
        data: {
          labels: ['Placeholder 1', 'Placeholder 2', 'Placeholder 3'],
          datasets: [{
            data: [33, 33, 34],
            backgroundColor: [
              tokens[tokenName].color + '99',
              tokens[tokenName].color + '66',
              tokens[tokenName].color + '33'
            ],
            borderColor: '#000',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: true,
          plugins: {
            legend: {
              position: 'bottom',
              labels: { font: { size: 10 } }
            },
            tooltip: { enabled: false }
          }
        }
      });
    }

    // Fetch current price for buy price
    fetchBuyPriceBtn.addEventListener('click', async () => {
      const price = await fetchCurrentPrice();
      if (price) document.getElementById('buyPrice').value = price.toFixed(6);
    });

    // Fetch current price for sell price
    fetchSellPriceBtn.addEventListener('click', async () => {
      const price = await fetchCurrentPrice();
      if (price) document.getElementById('sellPrice').value = price.toFixed(6);
    });

    // Form submission handler
    form.addEventListener('submit', (e) => {
      e.preventDefault();
      const investment = parseFloat(document.getElementById('investment').value);
      const buyPrice = parseFloat(document.getElementById('buyPrice').value);
      const sellPrice = parseFloat(document.getElementById('sellPrice').value);
      const investmentFee = parseFloat(document.getElementById('investmentFee').value) || 0;
      const exitFee = parseFloat(document.getElementById('exitFee').value) || 0;

      if (isNaN(investment) || isNaN(buyPrice) || isNaN(sellPrice) || investment <= 0 || buyPrice <= 0 || sellPrice <= 0) {
        error.textContent = 'Please fill in all fields with valid numbers.';
        error.style.display = 'block';
        results.classList.add('hidden');
        return;
      }

      error.style.display = 'none';
      const units = investment / buyPrice;
      const totalCost = investment + (investment * investmentFee / 100);
      const totalRevenue = (units * sellPrice) * (1 - exitFee / 100);
      const profitLoss = totalRevenue - totalCost;
      const roi = (profitLoss / totalCost) * 100;

      document.getElementById('units').textContent = units.toFixed(2);
      document.getElementById('totalCost').textContent = totalCost.toFixed(2);
      document.getElementById('totalRevenue').textContent = totalRevenue.toFixed(2);
      document.getElementById('profitLoss').textContent = profitLoss.toFixed(2);
      document.getElementById('roi').textContent = roi.toFixed(2);
      results.classList.remove('hidden');
    });

    // Initial load and periodic updates
    async function init() {
      await renderChart();
      await renderHolderChart('VDO');
      renderPieChart();
      const price = await fetchCurrentPrice();
      if (price) {
        document.getElementById('buyPrice').value = price.toFixed(6);
        document.getElementById('sellPrice').value = price.toFixed(6);
      }
    }

    init();
    setInterval(fetchCurrentPrice, 10000); // Update price every 10 seconds
    setInterval(renderChart, 300000); // Update chart every 5 minutes
  </script>
</body>
</html>
