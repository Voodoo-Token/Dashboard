<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Voodoo Token Dashboard</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      background-color: #0c3c4c;
      color: #000;
      font-family: 'Arial', sans-serif;
      margin: 0;
      padding: 10px;
    }
    .container {
      max-width: 800px;
      margin: 0 auto;
      background: #c0c0c0;
      border: 2px solid;
      border-color: #fff #000 #000 #fff;
      box-shadow: 2px 2px 0 #000;
    }
    .window {
      margin: 10px;
      background: #c0c0c0;
      border: 2px solid;
      border-color: #fff #000 #000 #fff;
    }
    .title-bar {
      background: linear-gradient(to right, #000080, #87ceeb);
      color: #fff;
      padding: 2px 5px;
      font-size: 12px;
      font-weight: bold;
    }
    .content {
      padding: 10px;
    }
    .win95-input {
      background: #fff;
      border: 2px solid;
      border-color: #000 #fff #fff #000;
      padding: 2px;
      font-size: 12px;
    }
    .win95-button {
      background: #c0c0c0;
      border: 2px solid;
      border-color: #fff #000 #000 #fff;
      padding: 2px 10px;
      cursor: pointer;
      font-size: 12px;
    }
    .win95-button:active {
      border-color: #000 #fff #fff #000;
      box-shadow: inset 1px 1px 0 #000;
    }
    .custom-button {
      background: #c0c0c0;
      color: #000;
      border: 2px solid;
      border-color: #fff #000 #000 #fff;
      padding: 5px 10px;
      text-align: center;
      display: inline-block;
      margin: 5px;
      font-size: 12px;
    }
    .custom-button:active {
      border-color: #000 #fff #fff #000;
      box-shadow: inset 1px 1px 0 #000;
    }
    canvas {
      background: #fff;
      border: 2px solid;
      border-color: #000 #fff #fff #000;
      width: 100%;
    }
    .charts-container {
      display: flex;
      justify-content: space-between;
      gap: 10px;
      max-width: 100%;
      flex-wrap: nowrap;
    }
    .holder-window {
      flex: 3;
      max-width: 60%;
    }
    .pie-window {
      flex: 2;
      max-width: 40%;
    }
    .holder-chart {
      height: 200px; /* Half the size of price chart */
      width: 100%;
    }
    .pie-chart {
      width: 150px;
      height: 150px;
    }
    .logo {
      width: 64px;
      height: 64px;
      margin: 5px;
      border: 2px solid;
      border-color: #fff #000 #000 #fff;
      cursor: pointer;
    }
    .logo:hover, .logo.selected {
      border-color: #FFFF00;
    }
    .token-selector {
      display: flex;
      justify-content: center;
      margin: 10px 0;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="token-selector">
      <img src="https://lcw.nyc3.cdn.digitaloceanspaces.com/production/currencies/64/vdo.png" alt="Voodoo Token Logo" class="logo selected" data-token="VDO">
      <img src="https://lcw.nyc3.cdn.digitaloceanspaces.com/production/currencies/64/__________magic.png" alt="Magic Token Logo" class="logo" data-token="MAGIC">
      <img src="https://lcw.nyc3.cdn.digitaloceanspaces.com/production/currencies/64/__poison.png" alt="Poison Token Logo" class="logo" data-token="POISON">
    </div>
    <div class="window">
      <div class="title-bar">Voodoo Token Investment Calculator</div>
      <div class="content">
        <form id="investmentForm">
          <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div>
              <label for="investment" class="block text-sm">Investment Amount (USD)</label>
              <input type="number" id="investment" step="0.01" min="0" class="win95-input mt-1 w-full" placeholder="e.g., 1000">
            </div>
            <div>
              <label for="buyPrice" class="block text-sm">Buy Price (USD per Token)</label>
              <input type="number" id="buyPrice" step="0.000001" min="0" class="win95-input mt-1 w-full" placeholder="e.g., 0.000337">
              <button type="button" id="fetchBuyPrice" class="win95-button mt-2">Check Price</button>
            </div>
            <div>
              <label for="sellPrice" class="block text-sm">Sell Price (USD per Token)</label>
              <input type="number" id="sellPrice" step="0.000001" min="0" class="win95-input mt-1 w-full" placeholder="e.g., 0.001">
              <button type="button" id="fetchSellPrice" class="win95-button mt-2">Check Price</button>
            </div>
            <div>
              <label for="investmentFee" class="block text-sm">Investment Fee (%)</label>
              <input type="number" id="investmentFee" step="0.01" min="0" class="win95-input mt-1 w-full" placeholder="e.g., 1.5">
              <label for="exitFee" class="block text-sm mt-4">Exit Fee (%)</label>
              <input type="number" id="exitFee" step="0.01" min="0" class="win95-input mt-1 w-full" placeholder="e.g., 1.5">
            </div>
          </div>
          <button type="submit" class="win95-button mt-6 w-full" id="calculateButton">Calculate</button>
        </form>
      </div>
    </div>
    <div class="window hidden" id="resultsWindow">
      <div class="title-bar">Investment Results</div>
      <div class="content" id="results">
        <p><strong>Units Purchased:</strong> <span id="units"></span> Tokens</p>
        <p><strong>Total Cost:</strong> $<span id="totalCost"></span></p>
        <p><strong>Total Revenue:</strong> $<span id="totalRevenue"></span></p>
        <p><strong>Profit/Loss:</strong> $<span id="profitLoss"></span></p>
        <p><strong>ROI:</strong> <span id="roi"></span>%</p>
      </div>
    </div>
    <div class="window">
      <div class="title-bar">Historical Price (Last 30 Days)</div>
      <div class="content">
        <canvas id="priceChart"></canvas>
      </div>
    </div>
    <div class="charts-container">
      <div class="window holder-window">
        <div class="title-bar">Token Holders</div>
        <div class="content">
          <canvas id="holderChart" class="holder-chart"></canvas>
        </div>
      </div>
      <div class="window pie-window">
        <div class="title-bar">Token Distribution</div>
        <div class="content">
          <canvas id="pieChart" class="pie-chart"></canvas>
        </div>
      </div>
    </div>
    <div class="window">
      <div class="title-bar">What is this dashboard?</div>
      <div class="content">
        <textarea class="win95-input w-full h-24" id="SUSEText" readonly spellcheck="false">This dashboard helps you see how much you could make or lose by investing in Voodoo, Magic, or the Poison Reward Token. You can enter things like how much money you want to invest, the price you buy and sell at, and any fees. The dashboard will then show you your possible profit or loss. It also lets you check the current price and see how the price has changed over the last 30 days. Additionally, it tracks the number of token holders for the selected token (Voodoo, Magic, or Poison) starting from May 5, 2025, with a compact chart below the price chart that adapts to show daily, weekly, monthly, or yearly data to remain clear even after 10 years, alongside a placeholder distribution pie chart in a separate box.</textarea>
      </div>
    </div>
    <div class="window">
      <div class="title-bar">Links</div>
      <div class="content flex flex-wrap justify-center">
        <a href="https://voodootoken.com/" class="custom-button">Back to Website</a>
        <a href="https://voodootoken.com/hovihev/uploads/2025/01/Voodoo-Token-Whitepaper-V1.pdf" class="custom-button">Read Whitepaper</a>
        <a href="https://t.me/voodootokengroup/" class="custom-button">Join Telegram</a>
        <a href="https://x.com/Voodoo_Token" class="custom-button">Follow X</a>
      </div>
    </div>
  </div>

  <script>
    // LiveCoinWatch API configuration
    const API_KEY = 'ddd9175e-6cb0-4fed-babc-8a54cd255c0e';
    const API_URL = 'https://api.livecoinwatch.com/coins/single';
    const HISTORY_URL = 'https://api.livecoinwatch.com/coins/single/history';
    const PULSECHAIN_API = 'https://api.scan.pulsechain.com/api/v2/tokens/';

    // Cache durations (in seconds)
    const CURRENT_PRICE_CACHE_DURATION = 3600; // 1 hour
    const HISTORICAL_PRICE_CACHE_DURATION = 86400; // 24 hours
    const HOLDERS_CACHE_DURATION = 86400; // 24 hours

    // Token configurations
    const tokens = {
      VDO: {
        address: '0x1c5f8e8E84AcC71650F7a627cfA5B24B80f44f00',
        color: '#000080'
      },
      MAGIC: {
        address: '0xd63b9d8d6e38cb7fbfdceede3ce92f97f5aea7ac',
        color: '#800080'
      },
      POISON: {
        address: '0xb8c8761fed2aad5c0a75561bc604531a42c452e6',
        color: '#268137'
      }
    };

    // Form elements
    const form = document.getElementById('investmentForm');
    const resultsWindow = document.getElementById('resultsWindow');
    const calculateButton = document.getElementById('calculateButton');
    const fetchBuyPriceBtn = document.getElementById('fetchBuyPrice');
    const fetchSellPriceBtn = document.getElementById('fetchSellPrice');
    const logos = document.querySelectorAll('.logo');
    let selectedToken = 'VDO';
    let chartInstance = null;
    let holderChartInstance = null;
    let pieChartInstance = null;
    let buttonTimeout = null;

    // Token selector
    logos.forEach(logo => {
      logo.addEventListener('click', () => {
        logos.forEach(l => l.classList.remove('selected'));
        logo.classList.add('selected');
        selectedToken = logo.dataset.token;
        document.getElementById('buyPrice').value = '';
        document.getElementById('sellPrice').value = '';
        document.querySelector('.window:nth-child(4) .title-bar').textContent = `Historical ${selectedToken} Price (Last 30 Days)`;
        renderChart();
        renderHolderChart(selectedToken);
        renderPieChart();
      });
    });

    // Function to show error on button
    function showButtonError(message) {
      calculateButton.textContent = message;
      calculateButton.style.color = '#ff0000';
      
      if (buttonTimeout) {
        clearTimeout(buttonTimeout);
      }
      
      buttonTimeout = setTimeout(() => {
        calculateButton.textContent = 'Calculate';
        calculateButton.style.color = '';
        buttonTimeout = null;
      }, 5000);
    }

    // Map token names to API codes
    const tokenCodeMap = {
      'VDO': 'VDO',
      'MAGIC': '__________MAGIC',
      'POISON': '__POISON'
    };

    // Helper function to get cached data from localStorage
    function getCachedData(key) {
      try {
        const data = localStorage.getItem(key);
        return data ? JSON.parse(data) : null;
      } catch (err) {
        console.error(`Error reading ${key} from localStorage:`, err);
        return null;
      }
    }

    // Helper function to set cached data in localStorage
    function setCachedData(key, data, timestamp) {
      try {
        localStorage.setItem(key, JSON.stringify({ data, timestamp }));
      } catch (err) {
        console.error(`Error saving ${key} to localStorage:`, err);
      }
    }

    // Fetch current price for selected token
    async function fetchCurrentPrice() {
      const cacheKey = `voodoo_currentPrice_${selectedToken}`;
      const cached = getCachedData(cacheKey);
      const now = Date.now() / 1000;

      if (cached && (now - cached.timestamp) < CURRENT_PRICE_CACHE_DURATION) {
        console.log(`${selectedToken} current price from cache:`, cached.data);
        return cached.data;
      }

      try {
        const tokenCode = tokenCodeMap[selectedToken];
        const response = await fetch(API_URL, {
          method: 'POST',
          headers: {
            'content-type': 'application/json',
            'x-api-key': API_KEY
          },
          body: JSON.stringify({
            currency: 'USD',
            code: tokenCode,
            meta: false
          })
        });
        if (!response.ok) throw new Error(`API response not OK for ${tokenCode}`);
        const data = await response.json();
        console.log(`${selectedToken} current price from API:`, data.rate);
        
        setCachedData(cacheKey, data.rate, now);
        return data.rate;
      } catch (err) {
        console.error(`Error fetching price for ${selectedToken}:`, err);
        showButtonError(`Failed to fetch ${selectedToken} price.`);
        
        if (cached) {
          console.log(`${selectedToken} using outdated cached price:`, cached.data);
          return cached.data;
        }
        
        return selectedToken === 'VDO' ? 0.00033742909594797763 : 
               selectedToken === 'MAGIC' ? 0.000771673230634273 : 
               0.0010286399907437705;
      }
    }

    // Fetch historical price data
    async function fetchHistoricalPrice() {
      const cacheKey = `voodoo_historicalPrice_${selectedToken}`;
      const cached = getCachedData(cacheKey);
      const now = Date.now() / 1000;

      if (cached && (now - cached.timestamp) < HISTORICAL_PRICE_CACHE_DURATION) {
        console.log(`${selectedToken} historical data from cache:`, cached.data);
        return cached.data;
      }

      try {
        const tokenCode = tokenCodeMap[selectedToken];
        const end = new Date('2025-05-05').getTime();
        const start = end - 30 * 24 * 60 * 60 * 1000;
        const response = await fetch(HISTORY_URL, {
          method: 'POST',
          headers: {
            'content-type': 'application/json',
            'x-api-key': API_KEY
          },
          body: JSON.stringify({
            currency: 'USD',
            code: tokenCode,
            start,
            end
          })
        });
        if (!response.ok) throw new Error(`API response not OK for ${tokenCode}`);
        const data = await response.json();
        const historicalData = data.history.map(entry => ({
          date: new Date(entry.date).toLocaleDateString(),
          price: entry.rate
        }));
        console.log(`${selectedToken} historical data from API:`, historicalData);
        
        setCachedData(cacheKey, historicalData, now);
        return historicalData;
      } catch (err) {
        console.error(`Error fetching historical price for ${selectedToken}:`, err);
        
        if (cached) {
          console.log(`${selectedToken} using outdated cached historical data:`, cached.data);
          return cached.data;
        }
        
        return [];
      }
    }

    // Fetch holder count for a token
    async function fetchHolderCount(token) {
      const cacheKey = `holders_${token}_${new Date().toISOString().split('T')[0]}`;
      const cached = getCachedData(cacheKey);
      const now = Date.now() / 1000;

      if (cached && (now - cached.timestamp) < HOLDERS_CACHE_DURATION) {
        console.log(`${token} holders from cache:`, cached.data);
        return cached.data;
      }

      try {
        const response = await fetch(`${PULSECHAIN_API}${tokens[token].address}`, {
          method: 'GET',
          headers: {
            'accept': 'application/json'
          }
        });
        if (!response.ok) throw new Error(`API response not OK for ${token}`);
        const data = await response.json();
        const holders = data.holders_count;
        console.log(`${token} holders from API:`, holders);
        
        setCachedData(cacheKey, holders, now);
        return holders;
      } catch (err) {
        console.error(`Error fetching holders for ${token}:`, err);
        return null;
      }
    }

    // Aggregate holder data based on time range
    function aggregateHolderData(data) {
      const today = new Date('2025-05-05');
      const aggregated = [];
      const dailyLimit = 30; // 30 days of daily data
      const weeklyLimit = 365; // ~1 year of weekly data
      const monthlyLimit = 3 * 365; // ~3 years of monthly data

      let currentGroup = [];
      let currentDate = new Date(data[0].date);
      let groupType = 'daily';

      data.forEach((entry, index) => {
        const entryDate = new Date(entry.date);
        const daysDiff = (today - entryDate) / (1000 * 60 * 60 * 24);

        if (daysDiff <= dailyLimit) {
          groupType = 'daily';
          aggregated.push(entry);
        } else if (daysDiff <= weeklyLimit) {
          groupType = 'weekly';
          currentGroup.push(entry);
          if (entryDate.getDay() === 0 || index === data.length - 1) {
            if (currentGroup.length > 0) {
              const avgHolders = currentGroup.reduce((sum, e) => sum + e.holders, 0) / currentGroup.length;
              aggregated.push({
                date: currentGroup[0].date,
                holders: avgHolders
              });
              currentGroup = [];
            }
          }
        } else if (daysDiff <= monthlyLimit) {
          groupType = 'monthly';
          currentGroup.push(entry);
          if (entryDate.getDate() === 1 || index === data.length - 1) {
            if (currentGroup.length > 0) {
              const avgHolders = currentGroup.reduce((sum, e) => sum + e.holders, 0) / currentGroup.length;
              aggregated.push({
                date: currentGroup[0].date,
                holders: avgHolders
              });
              currentGroup = [];
            }
          }
        } else {
          groupType = 'yearly';
          currentGroup.push(entry);
          if (entryDate.getMonth() === 0 && entryDate.getDate() === 1 || index === data.length - 1) {
            if (currentGroup.length > 0) {
              const avgHolders = currentGroup.reduce((sum, e) => sum + e.holders, 0) / currentGroup.length;
              aggregated.push({
                date: currentGroup[0].date,
                holders: avgHolders
              });
              currentGroup = [];
            }
          }
        }
      });

      return aggregated;
    }

    // Simulate 10 years of holder data (for testing, replace with real data collection)
    async function getHolderData(token) {
      const cacheKey = `holder_history_${token}`;
      let holderData = getCachedData(cacheKey)?.data || [];
      const today = new Date('2025-05-05');
      const todayStr = today.toISOString().split('T')[0];

      // Check if today's data is already stored
      if (!holderData.find(d => d.date === todayStr)) {
        const holders = await fetchHolderCount(token);
        if (holders !== null) {
          holderData.push({
            date: todayStr,
            holders
          });
          setCachedData(cacheKey, holderData, Date.now() / 1000);
        }
      }

      // Simulate 10 years of data for testing (comment out in production)
      if (holderData.length === 1) {
        let lastHolders = holderData[0].holders;
        for (let i = 1; i < 3650; i++) {
          const date = new Date(today);
          date.setDate(date.getDate() - i);
          const dateStr = date.toISOString().split('T')[0];
          lastHolders += Math.floor(Math.random() * 10 - 5); // Random walk for simulation
          if (lastHolders < 0) lastHolders = 0;
          holderData.push({
            date: dateStr,
            holders: lastHolders
          });
        }
        holderData.reverse(); // Chronological order
        setCachedData(cacheKey, holderData, Date.now() / 1000);
      }

      return aggregateHolderData(holderData);
    }

    // Render holder chart for the selected token
    async function renderHolderChart(token) {
      const holderData = await getHolderData(token);
      const canvas = document.getElementById('holderChart');
      const ctx = canvas.getContext('2d');

      if (holderChartInstance) {
        holderChartInstance.destroy();
      }

      if (!holderData.length) {
        holderChartInstance = new Chart(ctx, {
          type: 'line',
          data: {
            labels: ['No Data'],
            datasets: [{
              label: `${token} Holders`,
              data: [0],
              borderColor: tokens[token].color,
              backgroundColor: tokens[token].color + '33',
              fill: true
            }]
          },
          options: {
            responsive: true,
            scales: {
              x: { title: { display: true, text: 'Date' } },
              y: { 
                title: { display: true, text: 'Holders' },
                ticks: { precision: 0 }
              }
            },
            plugins: {
              tooltip: { enabled: false },
              legend: { display: true }
            }
          }
        });
        return;
      }

      holderChartInstance = new Chart(ctx, {
        type: 'line',
        data: {
          labels: holderData.map(d => d.date),
          datasets: [{
            label: `${token} Holders`,
            data: holderData.map(d => d.holders),
            borderColor: tokens[token].color,
            backgroundColor: tokens[token].color + '33',
            fill: true
          }]
        },
        options: {
          responsive: true,
          scales: {
            x: { title: { display: true, text: 'Date' } },
            y: { 
              title: { display: true, text: 'Holders' },
              ticks: { precision: 0 }
            }
          },
          plugins: {
            tooltip: {
              callbacks: {
                label: function(context) {
                  return `${token} Holders: ${context.parsed.y.toFixed(0)}`;
                }
              }
            },
            legend: { display: true }
          }
        }
      });
    }

    // Render placeholder pie chart
    function renderPieChart() {
      const canvas = document.getElementById('pieChart');
      const ctx = canvas.getContext('2d');

      if (pieChartInstance) {
        pieChartInstance.destroy();
      }

      pieChartInstance = new Chart(ctx, {
        type: 'pie',
        data: {
          labels: ['Placeholder 1', 'Placeholder 2', 'Placeholder 3'],
          datasets: [{
            data: [33, 33, 34],
            backgroundColor: [
              tokens[selectedToken].color + '99',
              tokens[selectedToken].color + '66',
              tokens[selectedToken].color + '33'
            ],
            borderColor: '#000',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: true,
          plugins: {
            legend: {
              position: 'bottom',
              labels: { font: { size: 10 } }
            },
            tooltip: { enabled: false }
          }
        }
      });
    }

    // Render historical price chart
    async function renderChart() {
      const historicalData = await fetchHistoricalPrice();
      const chartContainer = document.getElementById('priceChart').parentElement;
      const canvas = document.getElementById('priceChart');
      
      chartContainer.style.display = 'block';
      const ctx = canvas.getContext('2d');
      
      if (chartInstance) {
        chartInstance.destroy();
      }

      if (!historicalData.length) {
        chartInstance = new Chart(ctx, {
          type: 'line',
          data: {
            labels: ['No Data'],
            datasets: [{
              label: `${selectedToken} Price (USD)`,
              data: [0],
              borderColor: tokens[selectedToken].color,
              backgroundColor: tokens[selectedToken].color + '33',
              fill: true
            }]
          },
          options: {
            responsive: true,
            scales: {
              x: { title: { display: true, text: 'Date' } },
              y: { 
                title: { display: true, text: 'Price (USD)' },
                ticks: {
                  callback: function(value) {
                    return '$' + value.toFixed(6);
                  }
                }
              }
            },
            plugins: {
              tooltip: { enabled: false },
              legend: { display: false }
            }
          }
        });
        return;
      }

      chartInstance = new Chart(ctx, {
        type: 'line',
        data: {
          labels: historicalData.map(d => d.date),
          datasets: [{
            label: `${selectedToken} Price (USD)`,
            data: historicalData.map(d => d.price),
            borderColor: tokens[selectedToken].color,
            backgroundColor: tokens[selectedToken].color + '33',
            fill: true
          }]
        },
        options: {
          responsive: true,
          scales: {
            x: { title: { display: true, text: 'Date' } },
            y: { 
              title: { display: true, text: 'Price (USD)' },
              ticks: {
                callback: function(value) {
                  return '$' + value.toFixed(6);
                }
              }
            }
          },
          plugins: {
            tooltip: {
              callbacks: {
                label: function(context) {
                  return `${selectedToken} Price: $${context.parsed.y.toFixed(6)}`;
                }
              }
            },
            legend: { display: true }
          }
        }
      });
    }

    // Fetch current price for buy price
    fetchBuyPriceBtn.addEventListener('click', async () => {
      const price = await fetchCurrentPrice();
      if (price) document.getElementById('buyPrice').value = price.toFixed(6);
    });

    // Fetch current price for sell price
    fetchSellPriceBtn.addEventListener('click', async () => {
      const price = await fetchCurrentPrice();
      if (price) document.getElementById('sellPrice').value = price.toFixed(6);
    });

    // Form submission handler
    form.addEventListener('submit', (e) => {
      e.preventDefault();
      const investment = parseFloat(document.getElementById('investment').value);
      const buyPrice = parseFloat(document.getElementById('buyPrice').value);
      const sellPrice = parseFloat(document.getElementById('sellPrice').value);
      const investmentFee = parseFloat(document.getElementById('investmentFee').value) || 0;
      const exitFee = parseFloat(document.getElementById('exitFee').value) || 0;

      if (isNaN(investment) || isNaN(buyPrice) || isNaN(sellPrice) || investment <= 0 || buyPrice <= 0 || sellPrice <= 0) {
        showButtonError('Please fill in all fields with valid numbers.');
        resultsWindow.classList.add('hidden');
        return;
      }

      const units = investment / buyPrice;
      const totalCost = investment + (investment * investmentFee / 100);
      const totalRevenue = (units * sellPrice) * (1 - exitFee / 100);
      const profitLoss = totalRevenue - totalCost;
      const roi = (profitLoss / totalCost) * 100;

      document.getElementById('units').textContent = units.toFixed(2);
      document.getElementById('totalCost').textContent = totalCost.toFixed(2);
      document.getElementById('totalRevenue').textContent = totalRevenue.toFixed(2);
      document.getElementById('profitLoss').textContent = profitLoss.toFixed(2);
      document.getElementById('roi').textContent = roi.toFixed(2);
      resultsWindow.classList.remove('hidden');
    });

    // Initialize charts
    renderChart();
    renderHolderChart('VDO');
    renderPieChart();
  </script>
</body>
</html>
